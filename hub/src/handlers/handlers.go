package handlers

import (
	"bytes"
	"encoding/json"
	"hub/src/database"
	"hub/src/utils"
	"io"
	"log"
	"net/http"
)

// Handler for the root path. This is where the subscriber will send the POST request.
// 5.3 Hub Verifies Intent of the Subscriber
// GET request to hub.callback URL in body, including hub.mode, hub.topic, hub.challenge
// hub.challange is a random string generated by the hub that the subscriber must return to verify the subscription
// Example: http://client:port/uDxZqPFoHQ?hub.mode=subscribe&hub.topic=/a/topic&hub.challenge=randomstring
func RootHandler(dbHandler *database.DBHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		// Make sure to close the body when done
		defer req.Body.Close()

		// Parse the form
		if err := req.ParseForm(); err != nil {
			http.Error(w, "Error parsing form", http.StatusBadRequest)
			return
		}

		callbackURL := req.Form.Get("hub.callback")
		mode := req.Form.Get("hub.mode")
		topic := req.Form.Get("hub.topic")
		secret := req.Form.Get("hub.secret")

		// If the mode is unsubscribe, remove the subscriber from the database
		if mode == "unsubscribe" {
			log.Printf("Unsubscription request - Callback URL: %s, topic: %s, mode: %s\n", callbackURL, topic, mode)
			dbHandler.RemoveSubscriber(callbackURL)
			return
		}

		log.Printf("Subscription request - Callback URL: %s, topic: %s, mode: %s\n", callbackURL, topic, mode)
		log.Printf("Verifying intent of subscriber...")

		// Perform GET request to hub.callback URL
		challenge := utils.GenerateRandomString(10)
		resp, err := http.Get(callbackURL + "?hub.mode=" + mode + "&hub.topic=" + topic + "&hub.challenge=" + challenge)

		if err != nil {
			http.Error(w, "Error verifying intent", http.StatusInternalServerError)
			log.Println("Error verifying intent of subscriber")
			return
		}
		defer resp.Body.Close()

		// Check if the response status code is 200 and the response body is equal to the hub.challenge value
		// If verified, publish the hub.topic to the hub.callback URL
		body, err := io.ReadAll(resp.Body)
		if err == nil && resp.StatusCode == http.StatusOK && string(body) == challenge {
			log.Println("Intent verified")
		}

		// Store the subscriber's callback URL, topic and secret in the database
		err = dbHandler.AddSubscriber(callbackURL, callbackURL, topic, secret)
		if err != nil {
			http.Error(w, "Error adding subscriber", http.StatusInternalServerError)
			log.Println("Error adding subscriber")
		} else {
			log.Println("Subscriber added successfully")
		}

		// Set the content type to JSON
		w.Header().Set("Content-Type", "application/json")
	}
}

// Generate JSON data and publish to all subscribers
func GenerateHandler(dbHandler *database.DBHandler) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		// Make sure to close the body when done
		defer req.Body.Close()
		// Set the content type to JSON
		w.Header().Set("Content-Type", "application/json")

		topic := req.URL.Query().Get("topic")
		if topic == "" {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]string{"error": "No topic provided"})
			return
		}
		log.Println("Generate request for topic:", topic)

		// Get all subscribers from the database
		subscribers, err := dbHandler.GetTopicSubscribers(topic)
		if err != nil {
			log.Println("Error getting subscribers:", err)
			w.WriteHeader(http.StatusInternalServerError)
			json.NewEncoder(w).Encode(map[string]string{"error": "Something went wrong"})
			return
		}

		// Generate a random user that will be published to all subscribers of the topic
		user := utils.GenerateUser()

		// Publish the JSON data to all subscribers
		for _, subscriber := range subscribers {
			log.Println("Publishing data to subscriber:", subscriber)

			userJSON, _ := json.Marshal(user)
			buffer := bytes.NewBuffer(userJSON)
			log.Println("Data to be published:", buffer.String())

			req, err := http.NewRequest("POST", subscriber.CallbackURL, buffer)
			hmacHash := utils.HashWithHMAC(buffer.Bytes(), []byte(subscriber.Secret))
			hmacHash = "sha256=" + hmacHash

			if err != nil {
				log.Printf("Error sending data to subscriber %s: %v", subscriber.CallbackURL, err)
			}

			// Set headers
			req.Header.Set("X-Hub-Signature", hmacHash)

			// Perform the POST request
			resp, err := http.DefaultClient.Do(req)
			if err != nil || resp.StatusCode != http.StatusOK {
				log.Printf("Error sending data to subscriber %s: %v", subscriber.CallbackURL, err)
			}

			// Close the response body
			defer resp.Body.Close()

			if resp.StatusCode != http.StatusOK {
				log.Printf("Status: %s", resp.Status)
			}

			log.Printf("Successfully sent data to subscriber %s, status: %s", subscriber.CallbackURL, resp.Status)
		}

		// Return the JSON data
		json.NewEncoder(w).Encode(user)
	}
}
